# Introduction à l'exploitation Windows | Théorie 

Bonjour à tous !
On se retrouve pour un article toujours basique. En effet aujourd'hui on va parler théorie.

Quand on commence le pwn on se tourne plutôt vers l'exploitation sous Linux et les challenges n'en manquent pas ! Ducoup on oublie souvent Windows qui est plus present sur le marché. 

## Les sécurité sous windows

Vous devez sans doute connaitre l'ASLR, la NX, la PIE ou le stack canary. Ces protections sont aussi presente sur Windows mais sous un autre nom et quelque petites difference.

- Le DEP: Data Execution Prevention est le NX pour Windows. Pas de difference
- L'ASLR: Adress Space Layout Randomization à le même nom sous Windows mais attention ! Trois différence: l'ASLR n'est chargé qu'au démarrage ce qui veut dire que si le programme vicitme est redémarré les addresse ne change pas. Vous pouvez donc ignorer cette protection pour un exploit local mais si vous voulez créer un exploit qui marche partout vous devrez prendre e compte cette sécurité. Deuxième particuliarité: chaque programme peut être compilé avec ou sans ASLR (l'ASLR n'est plus presente sur tout le système mais depend du binaire). Troisième particuliarité: l'ASLR windows = ASLR + PIE, non seulement la heap et la stack sont randomizé par l'ASLR Windows mais les bibliothèque sont mappé à des addresse différentes aussi.
- Le GS, c'est un stack canary qui fonctionne comme le canary sur Linux un "cookie" est placé à la fin du buffer et ont vérifie si celui ci ne change pas, s'il change le programme est arreté pour éviter l'exploitation 

## Délivré des format strings ! 

Bon, les formats strings ... Comment dire que c'est juste du CTF et rien d'autre vous ne trouverez jamais un format string dans la vie réelle. Les formats strings peuvent être utile parfois: un programme avec la PIE, les format strings permettent un Memory Leak ce qui peut simplifier l'exploit sauf qu'il ne faut pas rêver cette vulnerablilité est très très peu présente. Alors revenons au sujets sous Windows les format strings n'existent tous simplement pas ! Pourquoi ? Il y'a longtemps une format string trainait sur Windows, Microsoft à juste décider qui'il ne faut pas patcher cette vulnérabilité et qu'il faut juste désactiver le formateur %n qui est obligatoir pour l'exploitation d'un format string.

Pour resumer: Sous Windows vous n'aurez jamais à exploiter cette vulnérabilité ! 

## Note sur les shellcodes

Vous n'êtes pas sans savoir qu'un shellcode doit executer un syscall: le plus souvent execve() voici par exemple le code d'un shellcode Linux pioché sur zeste du savoir: 
```asm
bits 32

shellcode:
    ; On réinitialise les registres
    xor eax, eax
    xor ebx, ebx
    xor ecx, ecx
    xor edx, edx

    ; Appel système 11
    mov al, 11

    ; ebx doit contenir un pointeur vers //bin/sh
    ; donc on construit la chaîne sur la pile

    push ebx ; ebx = 0, donc on a notre null-byte
    push `n/sh`
    push `//bi`

    ; A ce moment là, esp pointe sur `//bin/sh\0`
    mov ebx, esp ; on met dans ebx l'adresse de notre chaîne.

    ; ecx et edx valent déjà zéro (NULL)
    ; donc nous sommes tranquilles :)

    ; On exécute l'appel système
    int 0x80

    ; Et on quitte proprement
    ; (cf. shellcode Hello World)
    mov al, 1
    xor ebx, ebx
    int 0x80
```

Et Windows dans tout ça ? vous voyez le int 0x80 (cette instruction execute le syscall dont le numéro est eax (al ici pour éviter les nullbyte) le numero de execve est 11 en x86. 
Eh bien sur Windows ont pas les syscalls: de base ont ne peut pas créer de programme executant des syscalls directement, on doit passer par l'API WinAPI pour nos drivers ect .. 

Petite parenthèse importante sur la WinAPI:
Pour faire simple cette API appele des focntion interne de la NtAPI (qui n'est pas documenté) qui fait les appels système.
NtAPI est implémenté dans un libraire dll (on reviendra sur ça dans la suite) ntdll.dll 




